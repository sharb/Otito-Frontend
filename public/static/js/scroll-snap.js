!function(Q,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports["scroll-snap"]=n():Q["scroll-snap"]=n()}(this,function(){return function(Q){function n(F){if(B[F])return B[F].exports;var I=B[F]={i:F,l:!1,exports:{}};return Q[F].call(I.exports,I,I.exports,n),I.l=!0,I.exports}var B={};return n.m=Q,n.c=B,n.i=function(Q){return Q},n.d=function(Q,B,F){n.o(Q,B)||Object.defineProperty(Q,B,{configurable:!1,enumerable:!0,get:F})},n.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return n.d(B,"a",B),B},n.o=function(Q,n){return Object.prototype.hasOwnProperty.call(Q,n)},n.p="",n(n.s=1)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = function (element, config) {\n  if (config.scrollTimeout && (isNaN(config.scrollTimeout) || typeof config.scrollTimeout === 'boolean')) {\n    throw new Error('Optional config property \\'scrollTimeout\\' is not valid, expected NUMBER but found ' + _typeof(config.scrollTimeout).toUpperCase());\n  }\n  var SCROLL_TIMEOUT = config.scrollTimeout || SCROLL_TIMEOUT_DEFAULT;\n\n  if (config.scrollTime && (isNaN(config.scrollTime) || typeof config.scrollTime === 'boolean')) {\n    throw new Error('Optional config property \\'scrollTime\\' is not valid, expected NUMBER but found ' + _typeof(config.scrollTime).toUpperCase());\n  }\n  var SCROLL_TIME = config.scrollTime || SCROLL_TIME_DEFAULT;\n\n  if (!config.scrollSnapDestination) {\n    throw new Error('Required config property scrollSnapDestination is not defined');\n  }\n  var SCROLL_SNAP_DESTINATION = config.scrollSnapDestination;\n\n  var onAnimationEnd = void 0;\n  var timeOutId = null;\n  var scrollStart = null;\n  var animating = false;\n  var timer = 0;\n  var speedDeltaX = void 0;\n  var speedDeltaY = void 0;\n  var target = void 0;\n  var lastObj = void 0;\n  var lastScrollObj = void 0;\n  var lastScrollValue = {\n    x: null,\n    y: null\n  };\n\n  function checkScrollSpeed(value, axis) {\n    function clear() {\n      lastScrollValue[axis] = null;\n    }\n\n    var newValue = value;\n    var delta = void 0;\n    if (lastScrollValue[axis] !== null) {\n      delta = newValue - lastScrollValue[axis];\n    } else {\n      delta = 0;\n    }\n    lastScrollValue[axis] = newValue;\n    timer && clearTimeout(timer);\n    timer = setTimeout(clear, 50);\n    return delta;\n  }\n\n  function saveDeclaration(obj) {\n    obj.snapLengthUnit = parseSnapCoordValue(SCROLL_SNAP_DESTINATION);\n  }\n\n  function bindElement(element) {\n    target = element === document ? document.body : element;\n\n    /**\n     * set webkit-overflow-scrolling to auto.\n     * this prevents momentum scrolling on ios devices\n     * causing flickering behaviours and delayed transitions.\n     */\n    element.style.overflow = 'auto';\n    element.style.webkitOverflowScrolling = 'auto';\n\n    element.addEventListener('scroll', startAnimation, false);\n    saveDeclaration(target);\n  }\n\n  function unbindElement(element) {\n    element.style.webkitOverflowScrolling = null;\n    element.removeEventListener('scroll', startAnimation, false);\n  }\n\n  function startAnimation() {\n    speedDeltaX = checkScrollSpeed(target.scrollLeft, 'x');\n    speedDeltaY = checkScrollSpeed(target.scrollTop, 'y');\n    if (animating || speedDeltaX === 0 && speedDeltaY === 0) {\n      return;\n    }\n\n    handler(target);\n  }\n\n  /**\n   * scroll handler\n   * this is the callback for scroll events.\n   */\n  function handler(target) {\n    // use evt.target as target-element\n    lastObj = target;\n\n    lastScrollObj = getScrollObj(lastObj);\n\n    // if currently animating, stop it. this prevents flickering.\n    if (animationFrame) {\n      // cross browser\n      if (!window.cancelAnimationFrame(animationFrame)) {\n        clearTimeout(animationFrame);\n      }\n    }\n\n    // if a previous timeout exists, clear it.\n    if (timeOutId) {\n      // we only want to call a timeout once after scrolling..\n      clearTimeout(timeOutId);\n    } else {\n      scrollStart = {\n        y: lastScrollObj.scrollTop,\n        x: lastScrollObj.scrollLeft\n      };\n    }\n\n    timeOutId = setTimeout(animationHandler, SCROLL_TIMEOUT);\n  }\n\n  function animationHandler() {\n    // if we don't move a thing, we can ignore the timeout: if we did, there'd be another timeout added for scrollStart+1.\n    if (scrollStart.y === lastScrollObj.scrollTop && scrollStart.x === lastScrollObj.scrollLeft) {\n      // ignore timeout\n      return;\n    }\n\n    // detect direction of scroll. negative is up, positive is down.\n    var direction = {\n      y: speedDeltaY > 0 ? 1 : -1,\n      x: speedDeltaX > 0 ? 1 : -1\n    };\n    var snapPoint = void 0;\n\n    // get the next snap-point to snap-to\n    snapPoint = getNextSnapPoint(lastScrollObj, lastObj, direction);\n\n    lastObj.removeEventListener('scroll', startAnimation, false);\n\n    animating = true;\n\n    // smoothly move to the snap point\n    smoothScroll(lastScrollObj, snapPoint, function () {\n      // after moving to the snap point, rebind the scroll event handler\n      animating = false;\n      lastObj.addEventListener('scroll', startAnimation, false);\n      onAnimationEnd();\n    });\n\n    // we just jumped to the snapPoint, so this will be our next scrollStart\n    if (!isNaN(snapPoint.x || !isNaN(snapPoint.y))) {\n      scrollStart = snapPoint;\n    }\n  }\n\n  /**\n   * calculator for next snap-point\n   * @param  {Object} scrollObj - DOM element\n   * @param  {Object} obj - DOM element\n   * @param  {integer} direction - signed integer indicating the scroll direction\n   * @return {Object}\n   */\n  function getNextSnapPoint(scrollObj, obj, direction) {\n    // get snap length\n    var snapLength = {\n      y: roundByDirection(direction.y, getYSnapLength(obj, obj.snapLengthUnit.y)),\n      x: roundByDirection(direction.x, getXSnapLength(obj, obj.snapLengthUnit.x))\n    };\n    var top = scrollObj.scrollTop;\n    var left = scrollObj.scrollLeft;\n\n    // calc current and initial snappoint\n    var currentPoint = {\n      y: top / snapLength.y || 1,\n      x: left / snapLength.x || 1\n    };\n    var nextPoint = {\n      y: 0,\n      x: 0\n    };\n\n    // set target and bounds by direction\n    nextPoint.y = roundByDirection(direction.y, currentPoint.y);\n    nextPoint.x = roundByDirection(direction.x, currentPoint.x);\n\n    // calculate where to scroll\n    var scrollTo = {\n      y: nextPoint.y * snapLength.y,\n      x: nextPoint.x * snapLength.x\n    };\n\n    // stay in bounds (minimum: 0, maxmimum: absolute height)\n    scrollTo.y = stayInBounds(0, scrollObj.scrollHeight, scrollTo.y);\n    scrollTo.x = stayInBounds(0, scrollObj.scrollWidth, scrollTo.x);\n\n    return scrollTo;\n  }\n\n  /**\n   * ceil or floor a number based on direction\n   * @param  {Number} direction\n   * @param  {Number} currentPoint\n   * @return {Number}\n   */\n  function roundByDirection(direction, currentPoint) {\n    if (direction === -1) {\n      // when we go up, we floor the number to jump to the next snap-point in scroll direction\n      return Math.floor(currentPoint);\n    }\n    // go down, we ceil the number to jump to the next in view.\n    return Math.ceil(currentPoint);\n  }\n\n  /**\n   * keep scrolling in bounds\n   * @param  {Number} min\n   * @param  {Number} max\n   * @param  {Number} destined\n   * @return {Number}\n   */\n  function stayInBounds(min, max, destined) {\n    return Math.max(Math.min(destined, max), min);\n  }\n\n  /**\n   * parse snap destination/coordinate values.\n   * @param  {Object} declaration\n   * @return {Object}\n   */\n  function parseSnapCoordValue(declaration) {\n    // regex to parse lengths\n    var regex = /(\\d+)(px|%|vw) (\\d+)(px|%|vh)/g;\n    // defaults\n    var parsed = {\n      y: {\n        value: 0,\n        unit: 'px'\n      },\n      x: {\n        value: 0,\n        unit: 'px'\n      }\n    };\n    var parsable = void 0;\n    var result = void 0;\n\n    // parse value and unit\n    if (parsable !== null) {\n      result = regex.exec(declaration);\n      // if regexp fails, value is null\n      if (result !== null) {\n        parsed.x = {\n          value: result[1],\n          unit: result[2]\n        };\n        parsed.y = {\n          value: result[3],\n          unit: result[4]\n        };\n      }\n    }\n    return parsed;\n  }\n\n  /**\n   * calc length of one snap on y-axis\n   * @param  {Object} obj the scroll object\n   * @param  {Object} declaration the parsed declaration\n   * @return {Number}\n   */\n  function getYSnapLength(obj, declaration) {\n    if (declaration.unit === 'vh') {\n      // when using vh, one snap is the length of vh / 100 * value\n      return Math.max(document.documentElement.clientHeight, window.innerHeight || 1) / 100 * declaration.value;\n    } else if (declaration.unit === '%') {\n      // when using %, one snap is the length of element height / 100 * value\n      return obj.offsetHeight / 100 * declaration.value;\n    } else {\n      // when using px, one snap is the length of element height / value\n      return obj.offsetHeight / declaration.value;\n    }\n  }\n\n  /**\n   * calc length of one snap on x-axis\n   * @param  {Object} obj the scroll object\n   * @param  {Object} declaration the parsed declaration\n   * @return {Number}\n   */\n  function getXSnapLength(obj, declaration) {\n    if (declaration.unit === 'vw') {\n      // when using vw, one snap is the length of vw / 100 * value\n      return Math.max(document.documentElement.clientWidth, window.innerWidth || 1) / 100 * declaration.value;\n    } else if (declaration.unit === '%') {\n      // when using %, one snap is the length of element width / 100 * value\n      return obj.offsetWidth / 100 * declaration.value;\n    } else {\n      // when using px, one snap is the length of element width / value\n      return obj.offsetWidth / declaration.value;\n    }\n  }\n\n  /**\n   * return the element scrolling values are applied to.\n   * when receiving window.onscroll events, the actual scrolling is on the body.\n   * @param  {Object} obj - DOM element\n   * @return {Object}\n   */\n  function getScrollObj(obj) {\n    // if the scroll container is body, the scrolling is invoked on window/document.\n    if (obj === document || obj === window) {\n      // firefox scrolls on document.documentElement\n      if (document.documentElement.scrollTop > 0 || document.documentElement.scrollLeft > 0) {\n        return document.documentElement;\n      }\n      // chrome scrolls on body\n      return document.querySelector('body');\n    }\n\n    return obj;\n  }\n\n  /**\n   * ease in cubic function\n   * @param  {Number} t current time of the tween\n   * @param  {Number} b beginning value of the property\n   * @param  {Number} c change between the beginning and destination value\n   * @param  {Number} d is the total time of the tween\n   * @return {Number}   easing factor\n   */\n  function easeInCubic(t, b, c, d) {\n    return c * (t = t / d) * t * t + b;\n  }\n\n  /**\n   * calculate the scroll position we should be in\n   * @param  {Number} start    the start point of the scroll\n   * @param  {Number} end      the end point of the scroll\n   * @param  {Number} elapsed  the time elapsed from the beginning of the scroll\n   * @param  {Number} duration the total duration of the scroll (default 500ms)\n   * @return {Number}          the next position\n   */\n  function position(start, end, elapsed, duration) {\n    if (elapsed > duration) {\n      return end;\n    }\n    return easeInCubic(elapsed, start, end - start, duration);\n  }\n\n  /**\n   * is the starting position at the edge of the container?\n   * @param  {Object} start    the start coordinates of the scroll\n   * @param  {Object} end      the end coordinates of the scroll\n   * @return {Boolean}\n   */\n  function isEdge(start, end) {\n    return start.x === 0 && speedDeltaY === 0 || start.y === 0 && speedDeltaX === 0;\n  }\n\n  // a current animation frame\n  var animationFrame = null;\n\n  /**\n   * smoothScroll function by Alice Lietieur.\n   * @see https://github.com/alicelieutier/smoothScroll\n   * we use requestAnimationFrame to be called by the browser before every repaint\n   * @param  {Object}   obj      the scroll context\n   * @param  {Number}  end      where to scroll to\n   * @param  {Function} callback called when the scrolling is finished\n   */\n  function smoothScroll(obj, end, callback) {\n    var start = {\n      y: obj.scrollTop,\n      x: obj.scrollLeft\n    };\n\n    // get animation frame or a fallback\n    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {\n      window.setTimeout(fn, 15);\n    };\n    var duration = isEdge(start, end) ? 0 : SCROLL_TIME;\n    var startTime = null;\n\n    // setup the stepping function\n    function step(timestamp) {\n      if (!startTime) {\n        startTime = timestamp;\n      }\n      var elapsed = timestamp - startTime;\n\n      // change position on y-axis if result is a number.\n      if (!isNaN(end.y)) {\n        obj.scrollTop = position(start.y, end.y, elapsed, duration);\n      }\n\n      // change position on x-axis if result is a number.\n      if (!isNaN(end.x)) {\n        obj.scrollLeft = position(start.x, end.x, elapsed, duration);\n      }\n\n      // check if we are over due;\n      if (elapsed < duration) {\n        requestAnimationFrame(step);\n      } else {\n        // is there a callback?\n        if (typeof callback === 'function') {\n          // stop execution and run the callback\n          return callback(end);\n        }\n      }\n    }\n    animationFrame = requestAnimationFrame(step);\n  }\n\n  this.bind = function (callback) {\n    onAnimationEnd = typeof callback === 'function' ? callback : NOOP;\n\n    bindElement(element);\n  };\n\n  this.unbind = function () {\n    unbindElement(element);\n  };\n\n  return this;\n};\n\nvar SCROLL_TIMEOUT_DEFAULT = 300;\nvar SCROLL_TIME_DEFAULT = 2;\nvar NOOP = function NOOP() {};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJlbGVtZW50IiwiY29uZmlnIiwic2Nyb2xsVGltZW91dCIsImlzTmFOIiwiRXJyb3IiLCJ0b1VwcGVyQ2FzZSIsIlNDUk9MTF9USU1FT1VUIiwiU0NST0xMX1RJTUVPVVRfREVGQVVMVCIsInNjcm9sbFRpbWUiLCJTQ1JPTExfVElNRSIsIlNDUk9MTF9USU1FX0RFRkFVTFQiLCJzY3JvbGxTbmFwRGVzdGluYXRpb24iLCJTQ1JPTExfU05BUF9ERVNUSU5BVElPTiIsIm9uQW5pbWF0aW9uRW5kIiwidGltZU91dElkIiwic2Nyb2xsU3RhcnQiLCJhbmltYXRpbmciLCJ0aW1lciIsInNwZWVkRGVsdGFYIiwic3BlZWREZWx0YVkiLCJ0YXJnZXQiLCJsYXN0T2JqIiwibGFzdFNjcm9sbE9iaiIsImxhc3RTY3JvbGxWYWx1ZSIsIngiLCJ5IiwiY2hlY2tTY3JvbGxTcGVlZCIsInZhbHVlIiwiYXhpcyIsImNsZWFyIiwibmV3VmFsdWUiLCJkZWx0YSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJzYXZlRGVjbGFyYXRpb24iLCJvYmoiLCJzbmFwTGVuZ3RoVW5pdCIsInBhcnNlU25hcENvb3JkVmFsdWUiLCJiaW5kRWxlbWVudCIsImRvY3VtZW50IiwiYm9keSIsInN0eWxlIiwib3ZlcmZsb3ciLCJ3ZWJraXRPdmVyZmxvd1Njcm9sbGluZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdGFydEFuaW1hdGlvbiIsInVuYmluZEVsZW1lbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImhhbmRsZXIiLCJnZXRTY3JvbGxPYmoiLCJhbmltYXRpb25GcmFtZSIsIndpbmRvdyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0aW9uSGFuZGxlciIsImRpcmVjdGlvbiIsInNuYXBQb2ludCIsImdldE5leHRTbmFwUG9pbnQiLCJzbW9vdGhTY3JvbGwiLCJzY3JvbGxPYmoiLCJzbmFwTGVuZ3RoIiwicm91bmRCeURpcmVjdGlvbiIsImdldFlTbmFwTGVuZ3RoIiwiZ2V0WFNuYXBMZW5ndGgiLCJ0b3AiLCJsZWZ0IiwiY3VycmVudFBvaW50IiwibmV4dFBvaW50Iiwic2Nyb2xsVG8iLCJzdGF5SW5Cb3VuZHMiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsIk1hdGgiLCJmbG9vciIsImNlaWwiLCJtaW4iLCJtYXgiLCJkZXN0aW5lZCIsImRlY2xhcmF0aW9uIiwicmVnZXgiLCJwYXJzZWQiLCJ1bml0IiwicGFyc2FibGUiLCJyZXN1bHQiLCJleGVjIiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJjbGllbnRXaWR0aCIsImlubmVyV2lkdGgiLCJvZmZzZXRXaWR0aCIsInF1ZXJ5U2VsZWN0b3IiLCJlYXNlSW5DdWJpYyIsInQiLCJiIiwiYyIsImQiLCJwb3NpdGlvbiIsInN0YXJ0IiwiZW5kIiwiZWxhcHNlZCIsImR1cmF0aW9uIiwiaXNFZGdlIiwiY2FsbGJhY2siLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmbiIsInN0YXJ0VGltZSIsInN0ZXAiLCJ0aW1lc3RhbXAiLCJiaW5kIiwiTk9PUCIsInVuYmluZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7a0JBSWUsVUFBVUEsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7QUFDeEMsTUFDRUEsT0FBT0MsYUFBUCxLQUNDQyxNQUFNRixPQUFPQyxhQUFiLEtBQStCLE9BQU9ELE9BQU9DLGFBQWQsS0FBZ0MsU0FEaEUsQ0FERixFQUdFO0FBQ0EsVUFBTSxJQUFJRSxLQUFKLHlGQUNnRixRQUFRSCxPQUFPQyxhQUFmLEVBQThCRyxXQUE5QixFQURoRixDQUFOO0FBR0Q7QUFDRCxNQUFNQyxpQkFBaUJMLE9BQU9DLGFBQVAsSUFBd0JL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QUFrQ0MsUUFBbEMsQ0FBakI7QUFDRDs7QUFFRDtBQUNBLFVBQUlELFVBQVVDLFFBQWQsRUFBd0I7QUFDdEJHLDhCQUFzQkssSUFBdEI7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBLFlBQUksT0FBT04sUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQztBQUNBLGlCQUFPQSxTQUFTSixHQUFULENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRGpELHFCQUFpQnNELHNCQUFzQkssSUFBdEIsQ0FBakI7QUFDRDs7QUFFRCxPQUFLRSxJQUFMLEdBQVksVUFBVVIsUUFBVixFQUFvQjtBQUM5QjVGLHFCQUFpQixPQUFPNEYsUUFBUCxLQUFvQixVQUFwQixHQUFpQ0EsUUFBakMsR0FBNENTLElBQTdEOztBQUVBNUUsZ0JBQVl0QyxPQUFaO0FBQ0QsR0FKRDs7QUFNQSxPQUFLbUgsTUFBTCxHQUFjLFlBQVk7QUFDeEJyRSxrQkFBYzlDLE9BQWQ7QUFDRCxHQUZEOztBQUlBLFNBQU8sSUFBUDtBQUNELEM7O0FBM2JELElBQU1PLHlCQUF5QixHQUEvQjtBQUNBLElBQU1HLHNCQUFzQixDQUE1QjtBQUNBLElBQU13RyxPQUFPLFNBQVBBLElBQU8sR0FBTSxDQUFFLENBQXJCIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTQ1JPTExfVElNRU9VVF9ERUZBVUxUID0gMzAwXG5jb25zdCBTQ1JPTExfVElNRV9ERUZBVUxUID0gMlxuY29uc3QgTk9PUCA9ICgpID0+IHt9XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcpIHtcbiAgaWYgKFxuICAgIGNvbmZpZy5zY3JvbGxUaW1lb3V0ICYmXG4gICAgKGlzTmFOKGNvbmZpZy5zY3JvbGxUaW1lb3V0KSB8fCB0eXBlb2YgY29uZmlnLnNjcm9sbFRpbWVvdXQgPT09ICdib29sZWFuJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE9wdGlvbmFsIGNvbmZpZyBwcm9wZXJ0eSAnc2Nyb2xsVGltZW91dCcgaXMgbm90IHZhbGlkLCBleHBlY3RlZCBOVU1CRVIgYnV0IGZvdW5kICR7KHR5cGVvZiBjb25maWcuc2Nyb2xsVGltZW91dCkudG9VcHBlckNhc2UoKX1gXG4gICAgKVxuICB9XG4gIGNvbnN0IFNDUk9MTF9USU1FT1VUID0gY29uZmlnLnNjcm9sbFRpbWVvdXQgfHwgU0NST0xMX1RJTUVPVVRfREVGQVVMVFxuXG4gIGlmIChjb25maWcuc2Nyb2xsVGltZSAmJiAoaXNOYU4oY29uZmlnLnNjcm9sbFRpbWUpIHx8IHR5cGVvZiBjb25maWcuc2Nyb2xsVGltZSA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBPcHRpb25hbCBjb25maWcgcHJvcGVydHkgJ3Njcm9sbFRpbWUnIGlzIG5vdCB2YWxpZCwgZXhwZWN0ZWQgTlVNQkVSIGJ1dCBmb3VuZCAkeyh0eXBlb2YgY29uZmlnLnNjcm9sbFRpbWUpLnRvVXBwZXJDYXNlKCl9YFxuICAgIClcbiAgfVxuICBjb25zdCBTQ1JPTExfVElNRSA9IGNvbmZpZy5zY3JvbGxUaW1lIHx8IFNDUk9MTF9USU1FX0RFRkFVTFRcblxuICBpZiAoIWNvbmZpZy5zY3JvbGxTbmFwRGVzdGluYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIGNvbmZpZyBwcm9wZXJ0eSBzY3JvbGxTbmFwRGVzdGluYXRpb24gaXMgbm90IGRlZmluZWQnKVxuICB9XG4gIGNvbnN0IFNDUk9MTF9TTkFQX0RFU1RJTkFUSU9OID0gY29uZmlnLnNjcm9sbFNuYXBEZXN0aW5hdGlvblxuXG4gIGxldCBvbkFuaW1hdGlvbkVuZFxuICBsZXQgdGltZU91dElkID0gbnVsbFxuICBsZXQgc2Nyb2xsU3RhcnQgPSBudWxsXG4gIGxldCBhbmltYXRpbmcgPSBmYWxzZVxuICBsZXQgdGltZXIgPSAwXG4gIGxldCBzcGVlZERlbHRhWFxuICBsZXQgc3BlZWREZWx0YVlcbiAgbGV0IHRhcmdldFxuICBsZXQgbGFzdE9ialxuICBsZXQgbGFzdFNjcm9sbE9ialxuICBsZXQgbGFzdFNjcm9sbFZhbHVlID0ge1xuICAgIHg6IG51bGwsXG4gICAgeTogbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tTY3JvbGxTcGVlZCAodmFsdWUsIGF4aXMpIHtcbiAgICBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICBsYXN0U2Nyb2xsVmFsdWVbYXhpc10gPSBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZVxuICAgIGxldCBkZWx0YVxuICAgIGlmIChsYXN0U2Nyb2xsVmFsdWVbYXhpc10gIT09IG51bGwpIHtcbiAgICAgIGRlbHRhID0gbmV3VmFsdWUgLSBsYXN0U2Nyb2xsVmFsdWVbYXhpc11cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsdGEgPSAwXG4gICAgfVxuICAgIGxhc3RTY3JvbGxWYWx1ZVtheGlzXSA9IG5ld1ZhbHVlXG4gICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgIHRpbWVyID0gc2V0VGltZW91dChjbGVhciwgNTApXG4gICAgcmV0dXJuIGRlbHRhXG4gIH1cblxuICBmdW5jdGlvbiBzYXZlRGVjbGFyYXRpb24gKG9iaikge1xuICAgIG9iai5zbmFwTGVuZ3RoVW5pdCA9IHBhcnNlU25hcENvb3JkVmFsdWUoU0NST0xMX1NOQVBfREVTVElOQVRJT04pXG4gIH1cblxuICBmdW5jdGlvbiBiaW5kRWxlbWVudCAoZWxlbWVudCkge1xuICAgIHRhcmdldCA9IGVsZW1lbnQgPT09IGRvY3VtZW50ID8gZG9jdW1lbnQuYm9keSA6IGVsZW1lbnRcblxuICAgIC8qKlxuICAgICAqIHNldCB3ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nIHRvIGF1dG8uXG4gICAgICogdGhpcyBwcmV2ZW50cyBtb21lbnR1bSBzY3JvbGxpbmcgb24gaW9zIGRldmljZXNcbiAgICAgKiBjYXVzaW5nIGZsaWNrZXJpbmcgYmVoYXZpb3VycyBhbmQgZGVsYXllZCB0cmFuc2l0aW9ucy5cbiAgICAgKi9cbiAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nXG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRPdmVyZmxvd1Njcm9sbGluZyA9ICdhdXRvJ1xuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGFydEFuaW1hdGlvbiwgZmFsc2UpXG4gICAgc2F2ZURlY2xhcmF0aW9uKHRhcmdldClcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuYmluZEVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdE92ZXJmbG93U2Nyb2xsaW5nID0gbnVsbFxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhcnRBbmltYXRpb24sIGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24gKCkge1xuICAgIHNwZWVkRGVsdGFYID0gY2hlY2tTY3JvbGxTcGVlZCh0YXJnZXQuc2Nyb2xsTGVmdCwgJ3gnKVxuICAgIHNwZWVkRGVsdGFZID0gY2hlY2tTY3JvbGxTcGVlZCh0YXJnZXQuc2Nyb2xsVG9wLCAneScpXG4gICAgaWYgKGFuaW1hdGluZyB8fCAoc3BlZWREZWx0YVggPT09IDAgJiYgc3BlZWREZWx0YVkgPT09IDApKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBoYW5kbGVyKHRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBzY3JvbGwgaGFuZGxlclxuICAgKiB0aGlzIGlzIHRoZSBjYWxsYmFjayBmb3Igc2Nyb2xsIGV2ZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZXIgKHRhcmdldCkge1xuICAgIC8vIHVzZSBldnQudGFyZ2V0IGFzIHRhcmdldC1lbGVtZW50XG4gICAgbGFzdE9iaiA9IHRhcmdldFxuXG4gICAgbGFzdFNjcm9sbE9iaiA9IGdldFNjcm9sbE9iaihsYXN0T2JqKVxuXG4gICAgLy8gaWYgY3VycmVudGx5IGFuaW1hdGluZywgc3RvcCBpdC4gdGhpcyBwcmV2ZW50cyBmbGlja2VyaW5nLlxuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgLy8gY3Jvc3MgYnJvd3NlclxuICAgICAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWUpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25GcmFtZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhIHByZXZpb3VzIHRpbWVvdXQgZXhpc3RzLCBjbGVhciBpdC5cbiAgICBpZiAodGltZU91dElkKSB7XG4gICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gY2FsbCBhIHRpbWVvdXQgb25jZSBhZnRlciBzY3JvbGxpbmcuLlxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVPdXRJZClcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsU3RhcnQgPSB7XG4gICAgICAgIHk6IGxhc3RTY3JvbGxPYmouc2Nyb2xsVG9wLFxuICAgICAgICB4OiBsYXN0U2Nyb2xsT2JqLnNjcm9sbExlZnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lT3V0SWQgPSBzZXRUaW1lb3V0KGFuaW1hdGlvbkhhbmRsZXIsIFNDUk9MTF9USU1FT1VUKVxuICB9XG5cbiAgZnVuY3Rpb24gYW5pbWF0aW9uSGFuZGxlciAoKSB7XG4gICAgLy8gaWYgd2UgZG9uJ3QgbW92ZSBhIHRoaW5nLCB3ZSBjYW4gaWdub3JlIHRoZSB0aW1lb3V0OiBpZiB3ZSBkaWQsIHRoZXJlJ2QgYmUgYW5vdGhlciB0aW1lb3V0IGFkZGVkIGZvciBzY3JvbGxTdGFydCsxLlxuICAgIGlmIChzY3JvbGxTdGFydC55ID09PSBsYXN0U2Nyb2xsT2JqLnNjcm9sbFRvcCAmJiBzY3JvbGxTdGFydC54ID09PSBsYXN0U2Nyb2xsT2JqLnNjcm9sbExlZnQpIHtcbiAgICAgIC8vIGlnbm9yZSB0aW1lb3V0XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBkZXRlY3QgZGlyZWN0aW9uIG9mIHNjcm9sbC4gbmVnYXRpdmUgaXMgdXAsIHBvc2l0aXZlIGlzIGRvd24uXG4gICAgbGV0IGRpcmVjdGlvbiA9IHtcbiAgICAgIHk6IHNwZWVkRGVsdGFZID4gMCA/IDEgOiAtMSxcbiAgICAgIHg6IHNwZWVkRGVsdGFYID4gMCA/IDEgOiAtMVxuICAgIH1cbiAgICBsZXQgc25hcFBvaW50XG5cbiAgICAvLyBnZXQgdGhlIG5leHQgc25hcC1wb2ludCB0byBzbmFwLXRvXG4gICAgc25hcFBvaW50ID0gZ2V0TmV4dFNuYXBQb2ludChsYXN0U2Nyb2xsT2JqLCBsYXN0T2JqLCBkaXJlY3Rpb24pXG5cbiAgICBsYXN0T2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXJ0QW5pbWF0aW9uLCBmYWxzZSlcblxuICAgIGFuaW1hdGluZyA9IHRydWVcblxuICAgIC8vIHNtb290aGx5IG1vdmUgdG8gdGhlIHNuYXAgcG9pbnRcbiAgICBzbW9vdGhTY3JvbGwobGFzdFNjcm9sbE9iaiwgc25hcFBvaW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBhZnRlciBtb3ZpbmcgdG8gdGhlIHNuYXAgcG9pbnQsIHJlYmluZCB0aGUgc2Nyb2xsIGV2ZW50IGhhbmRsZXJcbiAgICAgIGFuaW1hdGluZyA9IGZhbHNlXG4gICAgICBsYXN0T2JqLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXJ0QW5pbWF0aW9uLCBmYWxzZSlcbiAgICAgIG9uQW5pbWF0aW9uRW5kKClcbiAgICB9KVxuXG4gICAgLy8gd2UganVzdCBqdW1wZWQgdG8gdGhlIHNuYXBQb2ludCwgc28gdGhpcyB3aWxsIGJlIG91ciBuZXh0IHNjcm9sbFN0YXJ0XG4gICAgaWYgKCFpc05hTihzbmFwUG9pbnQueCB8fCAhaXNOYU4oc25hcFBvaW50LnkpKSkge1xuICAgICAgc2Nyb2xsU3RhcnQgPSBzbmFwUG9pbnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRvciBmb3IgbmV4dCBzbmFwLXBvaW50XG4gICAqIEBwYXJhbSAge09iamVjdH0gc2Nyb2xsT2JqIC0gRE9NIGVsZW1lbnRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmogLSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSBkaXJlY3Rpb24gLSBzaWduZWQgaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBzY3JvbGwgZGlyZWN0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5leHRTbmFwUG9pbnQgKHNjcm9sbE9iaiwgb2JqLCBkaXJlY3Rpb24pIHtcbiAgICAvLyBnZXQgc25hcCBsZW5ndGhcbiAgICBsZXQgc25hcExlbmd0aCA9IHtcbiAgICAgIHk6IHJvdW5kQnlEaXJlY3Rpb24oZGlyZWN0aW9uLnksIGdldFlTbmFwTGVuZ3RoKG9iaiwgb2JqLnNuYXBMZW5ndGhVbml0LnkpKSxcbiAgICAgIHg6IHJvdW5kQnlEaXJlY3Rpb24oZGlyZWN0aW9uLngsIGdldFhTbmFwTGVuZ3RoKG9iaiwgb2JqLnNuYXBMZW5ndGhVbml0LngpKVxuICAgIH1cbiAgICBsZXQgdG9wID0gc2Nyb2xsT2JqLnNjcm9sbFRvcFxuICAgIGxldCBsZWZ0ID0gc2Nyb2xsT2JqLnNjcm9sbExlZnRcblxuICAgIC8vIGNhbGMgY3VycmVudCBhbmQgaW5pdGlhbCBzbmFwcG9pbnRcbiAgICBsZXQgY3VycmVudFBvaW50ID0ge1xuICAgICAgeTogdG9wIC8gc25hcExlbmd0aC55IHx8IDEsXG4gICAgICB4OiBsZWZ0IC8gc25hcExlbmd0aC54IHx8IDFcbiAgICB9XG4gICAgbGV0IG5leHRQb2ludCA9IHtcbiAgICAgIHk6IDAsXG4gICAgICB4OiAwXG4gICAgfVxuXG4gICAgLy8gc2V0IHRhcmdldCBhbmQgYm91bmRzIGJ5IGRpcmVjdGlvblxuICAgIG5leHRQb2ludC55ID0gcm91bmRCeURpcmVjdGlvbihkaXJlY3Rpb24ueSwgY3VycmVudFBvaW50LnkpXG4gICAgbmV4dFBvaW50LnggPSByb3VuZEJ5RGlyZWN0aW9uKGRpcmVjdGlvbi54LCBjdXJyZW50UG9pbnQueClcblxuICAgIC8vIGNhbGN1bGF0ZSB3aGVyZSB0byBzY3JvbGxcbiAgICBjb25zdCBzY3JvbGxUbyA9IHtcbiAgICAgIHk6IG5leHRQb2ludC55ICogc25hcExlbmd0aC55LFxuICAgICAgeDogbmV4dFBvaW50LnggKiBzbmFwTGVuZ3RoLnhcbiAgICB9XG5cbiAgICAvLyBzdGF5IGluIGJvdW5kcyAobWluaW11bTogMCwgbWF4bWltdW06IGFic29sdXRlIGhlaWdodClcbiAgICBzY3JvbGxUby55ID0gc3RheUluQm91bmRzKDAsIHNjcm9sbE9iai5zY3JvbGxIZWlnaHQsIHNjcm9sbFRvLnkpXG4gICAgc2Nyb2xsVG8ueCA9IHN0YXlJbkJvdW5kcygwLCBzY3JvbGxPYmouc2Nyb2xsV2lkdGgsIHNjcm9sbFRvLngpXG5cbiAgICByZXR1cm4gc2Nyb2xsVG9cbiAgfVxuXG4gIC8qKlxuICAgKiBjZWlsIG9yIGZsb29yIGEgbnVtYmVyIGJhc2VkIG9uIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGN1cnJlbnRQb2ludFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiByb3VuZEJ5RGlyZWN0aW9uIChkaXJlY3Rpb24sIGN1cnJlbnRQb2ludCkge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAvLyB3aGVuIHdlIGdvIHVwLCB3ZSBmbG9vciB0aGUgbnVtYmVyIHRvIGp1bXAgdG8gdGhlIG5leHQgc25hcC1wb2ludCBpbiBzY3JvbGwgZGlyZWN0aW9uXG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihjdXJyZW50UG9pbnQpXG4gICAgfVxuICAgIC8vIGdvIGRvd24sIHdlIGNlaWwgdGhlIG51bWJlciB0byBqdW1wIHRvIHRoZSBuZXh0IGluIHZpZXcuXG4gICAgcmV0dXJuIE1hdGguY2VpbChjdXJyZW50UG9pbnQpXG4gIH1cblxuICAvKipcbiAgICoga2VlcCBzY3JvbGxpbmcgaW4gYm91bmRzXG4gICAqIEBwYXJhbSAge051bWJlcn0gbWluXG4gICAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gICAqIEBwYXJhbSAge051bWJlcn0gZGVzdGluZWRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RheUluQm91bmRzIChtaW4sIG1heCwgZGVzdGluZWQpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZGVzdGluZWQsIG1heCksIG1pbilcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSBzbmFwIGRlc3RpbmF0aW9uL2Nvb3JkaW5hdGUgdmFsdWVzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRlY2xhcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU25hcENvb3JkVmFsdWUgKGRlY2xhcmF0aW9uKSB7XG4gICAgLy8gcmVnZXggdG8gcGFyc2UgbGVuZ3Roc1xuICAgIGxldCByZWdleCA9IC8oXFxkKykocHh8JXx2dykgKFxcZCspKHB4fCV8dmgpL2dcbiAgICAvLyBkZWZhdWx0c1xuICAgIGxldCBwYXJzZWQgPSB7XG4gICAgICB5OiB7XG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB1bml0OiAncHgnXG4gICAgICB9LFxuICAgICAgeDoge1xuICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgdW5pdDogJ3B4J1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGFyc2FibGVcbiAgICBsZXQgcmVzdWx0XG5cbiAgICAvLyBwYXJzZSB2YWx1ZSBhbmQgdW5pdFxuICAgIGlmIChwYXJzYWJsZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcmVnZXguZXhlYyhkZWNsYXJhdGlvbilcbiAgICAgIC8vIGlmIHJlZ2V4cCBmYWlscywgdmFsdWUgaXMgbnVsbFxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICBwYXJzZWQueCA9IHtcbiAgICAgICAgICB2YWx1ZTogcmVzdWx0WzFdLFxuICAgICAgICAgIHVuaXQ6IHJlc3VsdFsyXVxuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC55ID0ge1xuICAgICAgICAgIHZhbHVlOiByZXN1bHRbM10sXG4gICAgICAgICAgdW5pdDogcmVzdWx0WzRdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFxuICB9XG5cbiAgLyoqXG4gICAqIGNhbGMgbGVuZ3RoIG9mIG9uZSBzbmFwIG9uIHktYXhpc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iaiB0aGUgc2Nyb2xsIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRlY2xhcmF0aW9uIHRoZSBwYXJzZWQgZGVjbGFyYXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0WVNuYXBMZW5ndGggKG9iaiwgZGVjbGFyYXRpb24pIHtcbiAgICBpZiAoZGVjbGFyYXRpb24udW5pdCA9PT0gJ3ZoJykge1xuICAgICAgLy8gd2hlbiB1c2luZyB2aCwgb25lIHNuYXAgaXMgdGhlIGxlbmd0aCBvZiB2aCAvIDEwMCAqIHZhbHVlXG4gICAgICByZXR1cm4gKFxuICAgICAgICBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMSkgL1xuICAgICAgICAxMDAgKlxuICAgICAgICBkZWNsYXJhdGlvbi52YWx1ZVxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoZGVjbGFyYXRpb24udW5pdCA9PT0gJyUnKSB7XG4gICAgICAvLyB3aGVuIHVzaW5nICUsIG9uZSBzbmFwIGlzIHRoZSBsZW5ndGggb2YgZWxlbWVudCBoZWlnaHQgLyAxMDAgKiB2YWx1ZVxuICAgICAgcmV0dXJuIG9iai5vZmZzZXRIZWlnaHQgLyAxMDAgKiBkZWNsYXJhdGlvbi52YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aGVuIHVzaW5nIHB4LCBvbmUgc25hcCBpcyB0aGUgbGVuZ3RoIG9mIGVsZW1lbnQgaGVpZ2h0IC8gdmFsdWVcbiAgICAgIHJldHVybiBvYmoub2Zmc2V0SGVpZ2h0IC8gZGVjbGFyYXRpb24udmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogY2FsYyBsZW5ndGggb2Ygb25lIHNuYXAgb24geC1heGlzXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqIHRoZSBzY3JvbGwgb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gZGVjbGFyYXRpb24gdGhlIHBhcnNlZCBkZWNsYXJhdGlvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRYU25hcExlbmd0aCAob2JqLCBkZWNsYXJhdGlvbikge1xuICAgIGlmIChkZWNsYXJhdGlvbi51bml0ID09PSAndncnKSB7XG4gICAgICAvLyB3aGVuIHVzaW5nIHZ3LCBvbmUgc25hcCBpcyB0aGUgbGVuZ3RoIG9mIHZ3IC8gMTAwICogdmFsdWVcbiAgICAgIHJldHVybiAoXG4gICAgICAgIE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMSkgL1xuICAgICAgICAxMDAgKlxuICAgICAgICBkZWNsYXJhdGlvbi52YWx1ZVxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoZGVjbGFyYXRpb24udW5pdCA9PT0gJyUnKSB7XG4gICAgICAvLyB3aGVuIHVzaW5nICUsIG9uZSBzbmFwIGlzIHRoZSBsZW5ndGggb2YgZWxlbWVudCB3aWR0aCAvIDEwMCAqIHZhbHVlXG4gICAgICByZXR1cm4gb2JqLm9mZnNldFdpZHRoIC8gMTAwICogZGVjbGFyYXRpb24udmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2hlbiB1c2luZyBweCwgb25lIHNuYXAgaXMgdGhlIGxlbmd0aCBvZiBlbGVtZW50IHdpZHRoIC8gdmFsdWVcbiAgICAgIHJldHVybiBvYmoub2Zmc2V0V2lkdGggLyBkZWNsYXJhdGlvbi52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIGVsZW1lbnQgc2Nyb2xsaW5nIHZhbHVlcyBhcmUgYXBwbGllZCB0by5cbiAgICogd2hlbiByZWNlaXZpbmcgd2luZG93Lm9uc2Nyb2xsIGV2ZW50cywgdGhlIGFjdHVhbCBzY3JvbGxpbmcgaXMgb24gdGhlIGJvZHkuXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqIC0gRE9NIGVsZW1lbnRcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsT2JqIChvYmopIHtcbiAgICAvLyBpZiB0aGUgc2Nyb2xsIGNvbnRhaW5lciBpcyBib2R5LCB0aGUgc2Nyb2xsaW5nIGlzIGludm9rZWQgb24gd2luZG93L2RvY3VtZW50LlxuICAgIGlmIChvYmogPT09IGRvY3VtZW50IHx8IG9iaiA9PT0gd2luZG93KSB7XG4gICAgICAvLyBmaXJlZm94IHNjcm9sbHMgb24gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA+IDAgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICAgIH1cbiAgICAgIC8vIGNocm9tZSBzY3JvbGxzIG9uIGJvZHlcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JylcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICAvKipcbiAgICogZWFzZSBpbiBjdWJpYyBmdW5jdGlvblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHQgY3VycmVudCB0aW1lIG9mIHRoZSB0d2VlblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGIgYmVnaW5uaW5nIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGMgY2hhbmdlIGJldHdlZW4gdGhlIGJlZ2lubmluZyBhbmQgZGVzdGluYXRpb24gdmFsdWVcbiAgICogQHBhcmFtICB7TnVtYmVyfSBkIGlzIHRoZSB0b3RhbCB0aW1lIG9mIHRoZSB0d2VlblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgZWFzaW5nIGZhY3RvclxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQ3ViaWMgKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0ID0gdCAvIGQpICogdCAqIHQgKyBiXG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gd2Ugc2hvdWxkIGJlIGluXG4gICAqIEBwYXJhbSAge051bWJlcn0gc3RhcnQgICAgdGhlIHN0YXJ0IHBvaW50IG9mIHRoZSBzY3JvbGxcbiAgICogQHBhcmFtICB7TnVtYmVyfSBlbmQgICAgICB0aGUgZW5kIHBvaW50IG9mIHRoZSBzY3JvbGxcbiAgICogQHBhcmFtICB7TnVtYmVyfSBlbGFwc2VkICB0aGUgdGltZSBlbGFwc2VkIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Nyb2xsXG4gICAqIEBwYXJhbSAge051bWJlcn0gZHVyYXRpb24gdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBzY3JvbGwgKGRlZmF1bHQgNTAwbXMpXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgdGhlIG5leHQgcG9zaXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHBvc2l0aW9uIChzdGFydCwgZW5kLCBlbGFwc2VkLCBkdXJhdGlvbikge1xuICAgIGlmIChlbGFwc2VkID4gZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiBlbmRcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VJbkN1YmljKGVsYXBzZWQsIHN0YXJ0LCBlbmQgLSBzdGFydCwgZHVyYXRpb24pXG4gIH1cblxuICAvKipcbiAgICogaXMgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGF0IHRoZSBlZGdlIG9mIHRoZSBjb250YWluZXI/XG4gICAqIEBwYXJhbSAge09iamVjdH0gc3RhcnQgICAgdGhlIHN0YXJ0IGNvb3JkaW5hdGVzIG9mIHRoZSBzY3JvbGxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBlbmQgICAgICB0aGUgZW5kIGNvb3JkaW5hdGVzIG9mIHRoZSBzY3JvbGxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzRWRnZSAoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoc3RhcnQueCA9PT0gMCAmJiBzcGVlZERlbHRhWSA9PT0gMCkgfHwgKHN0YXJ0LnkgPT09IDAgJiYgc3BlZWREZWx0YVggPT09IDApXG4gIH1cblxuICAvLyBhIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lXG4gIGxldCBhbmltYXRpb25GcmFtZSA9IG51bGxcblxuICAvKipcbiAgICogc21vb3RoU2Nyb2xsIGZ1bmN0aW9uIGJ5IEFsaWNlIExpZXRpZXVyLlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGljZWxpZXV0aWVyL3Ntb290aFNjcm9sbFxuICAgKiB3ZSB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIGJlIGNhbGxlZCBieSB0aGUgYnJvd3NlciBiZWZvcmUgZXZlcnkgcmVwYWludFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb2JqICAgICAgdGhlIHNjcm9sbCBjb250ZXh0XG4gICAqIEBwYXJhbSAge051bWJlcn0gIGVuZCAgICAgIHdoZXJlIHRvIHNjcm9sbCB0b1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHNjcm9sbGluZyBpcyBmaW5pc2hlZFxuICAgKi9cbiAgZnVuY3Rpb24gc21vb3RoU2Nyb2xsIChvYmosIGVuZCwgY2FsbGJhY2spIHtcbiAgICBsZXQgc3RhcnQgPSB7XG4gICAgICB5OiBvYmouc2Nyb2xsVG9wLFxuICAgICAgeDogb2JqLnNjcm9sbExlZnRcbiAgICB9XG5cbiAgICAvLyBnZXQgYW5pbWF0aW9uIGZyYW1lIG9yIGEgZmFsbGJhY2tcbiAgICBsZXQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmbiwgMTUpXG4gICAgICB9XG4gICAgbGV0IGR1cmF0aW9uID0gaXNFZGdlKHN0YXJ0LCBlbmQpID8gMCA6IFNDUk9MTF9USU1FXG4gICAgbGV0IHN0YXJ0VGltZSA9IG51bGxcblxuICAgIC8vIHNldHVwIHRoZSBzdGVwcGluZyBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIHN0ZXAgKHRpbWVzdGFtcCkge1xuICAgICAgaWYgKCFzdGFydFRpbWUpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZXN0YW1wXG4gICAgICB9XG4gICAgICBjb25zdCBlbGFwc2VkID0gdGltZXN0YW1wIC0gc3RhcnRUaW1lXG5cbiAgICAgIC8vIGNoYW5nZSBwb3NpdGlvbiBvbiB5LWF4aXMgaWYgcmVzdWx0IGlzIGEgbnVtYmVyLlxuICAgICAgaWYgKCFpc05hTihlbmQueSkpIHtcbiAgICAgICAgb2JqLnNjcm9sbFRvcCA9IHBvc2l0aW9uKHN0YXJ0LnksIGVuZC55LCBlbGFwc2VkLCBkdXJhdGlvbilcbiAgICAgIH1cblxuICAgICAgLy8gY2hhbmdlIHBvc2l0aW9uIG9uIHgtYXhpcyBpZiByZXN1bHQgaXMgYSBudW1iZXIuXG4gICAgICBpZiAoIWlzTmFOKGVuZC54KSkge1xuICAgICAgICBvYmouc2Nyb2xsTGVmdCA9IHBvc2l0aW9uKHN0YXJ0LngsIGVuZC54LCBlbGFwc2VkLCBkdXJhdGlvbilcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIG92ZXIgZHVlO1xuICAgICAgaWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlzIHRoZXJlIGEgY2FsbGJhY2s/XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBzdG9wIGV4ZWN1dGlvbiBhbmQgcnVuIHRoZSBjYWxsYmFja1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlbmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcClcbiAgfVxuXG4gIHRoaXMuYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIG9uQW5pbWF0aW9uRW5kID0gdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBOT09QXG5cbiAgICBiaW5kRWxlbWVudChlbGVtZW50KVxuICB9XG5cbiAgdGhpcy51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdW5iaW5kRWxlbWVudChlbGVtZW50KVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _index = __webpack_require__(0);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar snapConfig = {\n  scrollSnapDestination: '0% 90%', // scroll-snap-destination css property\n  scrollTimeout: 100, // time in ms after which scrolling is considered finished\n  scrollTime: 300 // time in ms for the smooth snap\n};\n\nfunction callback() {\n  console.log('snap');\n}\n\nvar element = document.getElementById('container');\nvar snapObject = new _index2.default(element, snapConfig);\nsnapObject.bind(callback);\n\n// unbind element\n// snapObject.unbind();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kZW1vL3NyYy9pbmRleC5qcz83MmQ0Il0sIm5hbWVzIjpbInNuYXBDb25maWciLCJzY3JvbGxTbmFwRGVzdGluYXRpb24iLCJzY3JvbGxUaW1lb3V0Iiwic2Nyb2xsVGltZSIsImNhbGxiYWNrIiwiY29uc29sZSIsImxvZyIsImVsZW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic25hcE9iamVjdCIsImJpbmQiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7OztBQUVBLElBQU1BLGFBQWE7QUFDakJDLHlCQUF1QixRQUROLEVBQ2dCO0FBQ2pDQyxpQkFBZSxHQUZFLEVBRUc7QUFDcEJDLGNBQVksR0FISyxDQUdEO0FBSEMsQ0FBbkI7O0FBTUEsU0FBU0MsUUFBVCxHQUFxQjtBQUNuQkMsVUFBUUMsR0FBUixDQUFZLE1BQVo7QUFDRDs7QUFFRCxJQUFNQyxVQUFVQyxTQUFTQyxjQUFULENBQXdCLFdBQXhCLENBQWhCO0FBQ0EsSUFBTUMsYUFBYSxvQkFBZUgsT0FBZixFQUF3QlAsVUFBeEIsQ0FBbkI7QUFDQVUsV0FBV0MsSUFBWCxDQUFnQlAsUUFBaEI7O0FBRUE7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNjcm9sbFNuYXAgZnJvbSAnLi4vLi4vc3JjL2luZGV4J1xuXG5jb25zdCBzbmFwQ29uZmlnID0ge1xuICBzY3JvbGxTbmFwRGVzdGluYXRpb246ICcwJSA5MCUnLCAvLyBzY3JvbGwtc25hcC1kZXN0aW5hdGlvbiBjc3MgcHJvcGVydHlcbiAgc2Nyb2xsVGltZW91dDogMTAwLCAvLyB0aW1lIGluIG1zIGFmdGVyIHdoaWNoIHNjcm9sbGluZyBpcyBjb25zaWRlcmVkIGZpbmlzaGVkXG4gIHNjcm9sbFRpbWU6IDMwMCAvLyB0aW1lIGluIG1zIGZvciB0aGUgc21vb3RoIHNuYXBcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2sgKCkge1xuICBjb25zb2xlLmxvZygnc25hcCcpXG59XG5cbmNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbmNvbnN0IHNuYXBPYmplY3QgPSBuZXcgU2Nyb2xsU25hcChlbGVtZW50LCBzbmFwQ29uZmlnKVxuc25hcE9iamVjdC5iaW5kKGNhbGxiYWNrKVxuXG4vLyB1bmJpbmQgZWxlbWVudFxuLy8gc25hcE9iamVjdC51bmJpbmQoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RlbW8vc3JjL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")}])});